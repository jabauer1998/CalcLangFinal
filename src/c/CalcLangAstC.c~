#include "CalcLangAst.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void astToStr(AstNode* node, int size, char* str);

//Function to append a Character to the givin string
void appendStrChr(char a, int size, char* str){
  int actualLength = strlen(str);
  if(actualLength < (size - 1)){
    // Append the character
    str[actualLength] = a;
    // Add the new null terminator
    str[actualLength + 1] = '\0';
  }
}

//Function to Convert a StoreArray instance into a String
void storeArrayToStr(StoreArray* arrayWithLength, int size, char* str){
  int arrSize = arrayWithLength->length;
  AstNode** array = arrayWithLength->firstElem;
  for(int i = 0; i < arrSize; i++){
    if(i == 0){
      AstNode* data = array[i];
      astToStr(data, size, str);
    } else {
      strncat(", ", str, size);
      AstNode* data = array[i];
      astToStr(data, size, str);
    }
  }
}

//Functions for turning an abstract syntax tree back into a string
//This is for debugging purpouses to make sure everything is marshalled over correctly

char* astToString(AstNode* node){
  int size = 500;
  char* str = (char*)malloc(size);
  astToStr(node, size, str);
  return str;
}

void equalOperationToStr(EqualOperation* op, int size, char* str){
  astToStr(op->left, size, str);
  strncat(" = ", str, size);
  astToStr(op->right, size, str);
}

void lessThenOrEqualsOperationToStr(LessThenOrEqualsOperation* op, int size, char* str){
  astToStr(op->left, size, str);
  strncat(" <= ", str, size);
  astToStr(op->right, size, str);
}

void greaterThenOrEqualsOperationToStr(GreaterThenOrEqualsOperation* op, int size, char* str){
  astToStr(op->left, size, str);
  strncat(" >= ", str, size);
  astToStr(op->right, size, str);
}

void lessThenOperationToStr(LessThenOperation* op, int size, char* str){
  astToStr(op->left, size, str);
  strncat(" < ", str, size);
  astToStr(op->right, size, str);
}

void greaterThenOperationToStr(GreaterThenOperation* op, int size, char* str){
  astToStr(op->left, size, str);
  strncat(" > ", str, size);
  astToStr(op->right, size, str);
}

void additionOperationToStr(AdditionOperation* op, int size, char* str){
  astToStr(op->left, size, str);
  strncat(" + ", str, size);
  astToStr(op->right, size, str);
}

void subtractionOperationToStr(SubtractionOperation* op, int size, char* str){
  astToStr(op->left, size, str);
  strncat(" - ", str, size);
  astToStr(op->right, size, str);
}

void multiplicationOperationToStr(MultiplicationOperation* op, int size, char* str){
  astToStr(op->left, size, str);
  strncat("*", str, size);
  astToStr(op->right, size, str);
}

void dotProductOperationToStr(DotProductOperation* op, int size, char* str){
  astToStr(op->left, size, str);
  strncat(" . ", str, size);
  astToStr(op->right, size, str);
}

void divisionOperationToStr(DivisionOperation* op, int size, char* str){
  astToStr(op->left, size, str);
  strncat("/", str, size);
  astToStr(op->right, size, str);
}

void powerOperationToStr(PowerOperation* op, int size, char* str){
  astToStr(op->left, size, str);
  strncat("^", str, size);
  astToStr(op->right, size, str);
}

void integerAstToStr(IntNumberAst* i, int size, char* str){
  strncat(i->lexeme, str, size);
}

void realAstToStr(RealNumberAst* i, int size, char* str){
  strncat(i->lexeme, str, size);
}

void booleanAstToStr(BooleanAst* i, int size, char* str){
  strncat(i->lexeme, str, size);
}

void setAstToStr(SetAst* s, int size, char* str){
  strncat("{", str, size);
  storeArrayToStr(s->arr, size, str);
  strncat("}", str, size);
}

void tupleAstToStr(TupleAst* s, int size, char* str){
  strncat("(", str, size);
  storeArrayToStr(s->arr, size, str);
  strncat(")", str, size);
}

void identAstToStr(IdentAst* s, int size, char* str){
  appendStrChr(s->name, size, str);
}

void dollarAstToStr(DollarAst* d, int size, char* str){
  appendStrChr('$', size, str);
  strncat(d->lexeme, str, size);
}

void percentAstToStr(PercentAst* p, int size, char* str){
  strncat(p->lexeme, str, size);
  appendStrChr('%', size, str);
}

void functionCallToStr(FunctionCall* f, int size, char* str){
  appendStrChr(f->name, size, str);
  appendStrChr('(', size, str);
  storeArrayToStr(f->params, size, str);
  appendStrChr(')', size, str);
}

void negateOperationToStr(NegateOperation* n, int size, char* str){
  appendStrChr('-', size, str);
  astToStr(n->expr, size, str);
}

void notOperationToStr(NotOperation* n, int size, char* str){
  appendStrChr('\'', size, str);
  astToStr(n->expr, size, str);
}

void functionDefinitionToStr(FunctionDef* d, int size, char* str){
  strncat("func ", str, size);
  appendStrChr(d->name, size, str);
  appendStrChr('(', size, str);
  storeArrayToStr(d->param, size, str);
  strncat(") = ", str, size);
  astToStr(d->expr, size, str);
}

void assignmentToStr(Assign* a, int size, char* str){
  strncat("let ", str, size);
  appendStrChr(a->name, size, str);
  strncat(" = ", str, size);
  astToStr(a->expr, size, str);
}

void ifExpressionToStr (IfExpr* ify, int size, char* str){
  strncat("if ", str, size);
  astToStr(ify->cond, size, str);
  strncat(" then ", str, size);
  astToStr(ify->ifTrue, size, str);
  strncat(" else ", str, size);
  astToStr(ify->ifFalse, size, str);
}

void astToStr(AstNode* node, int size, char* str){
  switch(node->nodeType){
  case EQUAL_OPERATION:
    equalOperationToStr(&(node->actualNodeData.equalOperation), size, str);
    break;
  case LESS_THEN_OR_EQUALS_OPERATION:
    lessThenOrEqualsOperationToStr(&(node->actualNodeData.lessOrEqual), size, str);
    break;
  case GREATER_THEN_OR_EQUALS_OPERATION:
    greaterThenOrEqualsOperationToStr(&(node->actualNodeData.greaterOrEqual), size, str);
    break;
  case LESS_THEN_OPERATION:
    lessThenOperationToStr(&(node->actualNodeData.lessThen), size, str);
    break;
  case GREATER_THEN_OPERATION:
    greaterThenOperationToStr(&(node->actualNodeData.greaterThen), size, str);
    break;
  case ADDITION_OPERATION:
    additionOperationToStr(&(node->actualNodeData.addition), size, str);
    break;
  case SUBTRACTION_OPERATION:
    subtractionOperationToStr(&node->actualNodeData.subtraction, size, str);
    break;
  case MULTIPLICATON_OPERATION:
    multiplicationOperationToStr(&(node->actualNodeData.multiplication), size, str);
    break;
  case DOT_PRODUCT_OPERATION:
    dotProductOperationToStr(&(node->actualNodeData.dotProduct), size, str);
    break;
  case DIVISION_OPERATION:
    divisionOperationToStr(&(node->actualNodeData.division), size, str);
    break;
  case POWER_OPERATION:
    powerOperationToStr(&(node->actualNodeData.power), size, str);
    break;
  case INT_AST:
    integerAstToStr(&(node->actualNodeData.integer), size, str);
    break;
  case REAL_AST:
    realAstToStr(&(node->actualNodeData.real), size, str);
    break;
  case BOOL_AST:
    booleanAstToStr(&(node->actualNodeData.bool), size, str);
    break;
  case SET_AST:
    setAstToStr(&(node->actualNodeData.set), size, str);
    break;
  case TUPLE_AST:
    tupleAstToStr(&(node->actualNodeData.tuple), size, str);
    break;
  case IDENT_AST:
    identAstToStr(&(node->actualNodeData.ident), size, str);
    break;
  case DOLLAR_AST:
    dollarAstToStr(&(node->actualNodeData.dollar), size, str);
    break;
  case PERCENT_AST:
    percentAstToStr(&(node->actualNodeData.percent), size, str);
    break;
  case FUNCTION_CALL:
    functionCallToStr(&(node->actualNodeData.call), size, str);
    break;
  case NEGATE_OPERATION:
    negateOperationToStr(&(node->actualNodeData.negate), size, str);
    break;
  case NOT_OPERATION:
    notOperationToStr(&(node->actualNodeData.not), size, str);
    break;
  case FUNCTION_DEFINITION:
    functionDefinitionToStr(&(node->actualNodeData.function), size, str);
    break;
  case ASSIGN:
    assignmentToStr(&(node->actualNodeData.variable), size, str);
    break;
  case IF_EXPR:
    ifExpressionToStr(&(node->actualNodeData.ifStatement), size, str);
    break;
  default:
    fprintf(stderr, "Invalid number %d", node->nodeType);
    break;
  }
}



