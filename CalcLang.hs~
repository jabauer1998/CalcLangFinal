import Text.Parsec
import qualified Text.Parsec.Token as P
import Text.Parsec.Language (emptyDef)
import Text.Parsec.String
import Text.Parsec
import Text.Parsec.Char
import Data.Text (Text)
import System.IO
import Numeric



type Pos = SourcePos

data Token = Ident Char Pos
           | IntNum String Pos
           | RealNum String Pos
           | TF String Pos
           | Func Pos
           | Plus Pos
           | Minus Pos
           | Times Pos
           | Div Pos
           | Eq Pos
           | Pow Pos
           | Not Pos
           | Comma Pos
           | LPar Pos
           | RPar Pos
           | LBrack Pos
           | RBrack Pos
           | LessThen Pos
           | GreaterThen Pos
           | GtOrEq Pos
           | LtOrEq Pos
           | If Pos
           | Then Pos
           | Else Pos
           | Let Pos
           | Dol String Pos
           | Perc String Pos
           | Dot Pos
           deriving (Show, Eq)


type CalcLangLexer a = ParsecT String () IO a


parseLexeme :: (CalcLangLexer a) -> (CalcLangLexer a)
parseLexeme a = a <* spaces

parseIdent :: CalcLangLexer Token
parseIdent = do
             startPos <- getPosition
             restChars <- parseLexeme letter
             return (Ident restChars startPos)

parsePeriod :: CalcLangLexer Token
parsePeriod = do
              start <- getPosition
              parseLexeme (char '.')  >> return (Dot start)

parseNum :: CalcLangLexer Token
parseNum = (try parseRealNum) <|> try parseIntNum

parseRealNum :: CalcLangLexer Token
parseRealNum = do
               start <- getPosition
               result <- many1 digit
               parsePeriod
               resultRest <- parseLexeme (many1 digit)
               return (RealNum (result ++ ['.'] ++ resultRest) start)


parseIntNum :: CalcLangLexer Token
parseIntNum = do
              startPos <- getPosition
              result <- parseLexeme (many1 digit)
              return (IntNum  result startPos)

parseBool :: CalcLangLexer Token
parseBool = do
            startPos <- getPosition
            res <- parseLexeme (string "TRUE" <|> string "FALSE")
            return (TF res startPos)

parseComma :: CalcLangLexer Token
parseComma = do
             start <- getPosition
             parseLexeme (char ',') >> return (Comma start)

parsePlus :: CalcLangLexer Token
parsePlus = do
            startPosition <- getPosition
            parseLexeme (char '+') >> return (Plus startPosition)

parseMinus :: CalcLangLexer Token
parseMinus = do
             startPosition <- getPosition
             parseLexeme (char '-') >> return (Minus startPosition)

parseTimes :: CalcLangLexer Token
parseTimes = do
             startPosition <- getPosition
             parseLexeme (char '*') >> return (Minus startPosition)

parseNot :: CalcLangLexer Token
parseNot = do
           startPosition <- getPosition
           parseLexeme (char '\'') >> return (Not startPosition)
           
parseDiv :: CalcLangLexer Token
parseDiv = do
           startPosition <- getPosition
           parseLexeme (char '/') >> return (Div startPosition)

parseEq :: CalcLangLexer Token
parseEq = do
           startPosition <- getPosition
           parseLexeme (char '=') >> return (Eq startPosition)

parsePow :: CalcLangLexer Token
parsePow = do
           startPosition <- getPosition
           parseLexeme (char '^') >> return (Pow startPosition)

parseLPar :: CalcLangLexer Token
parseLPar = do
            start <- getPosition
            parseLexeme (char '(') >> return (LPar start)

parseRPar :: CalcLangLexer Token
parseRPar = do
            start <- getPosition
            parseLexeme (char ')') >> return (RPar start)

parseLBrack :: CalcLangLexer Token
parseLBrack = do
              start <- getPosition
              parseLexeme (char '{') >> return (LBrack start)

parseRBrack :: CalcLangLexer Token
parseRBrack = do
              start <- getPosition
              parseLexeme (char '}') >> return (RBrack start)

parseLT :: CalcLangLexer Token
parseLT = do
          startPosition <- getPosition
          parseLexeme (char '<') >> return (LessThen startPosition)

parseGT :: CalcLangLexer Token
parseGT = do
          startPosition <- getPosition
          parseLexeme (char '>') >> return (GreaterThen startPosition)

parseLtOrEq :: CalcLangLexer Token
parseLtOrEq = do
              startPosition <- getPosition
              parseLexeme (string "<=") >> return (LtOrEq startPosition)

parseGtOrEq :: CalcLangLexer Token
parseGtOrEq = do
              startPosition <- getPosition
              parseLexeme (string ">=") >> return (GtOrEq startPosition)

parseIf :: CalcLangLexer Token
parseIf = do
          startPosition <- getPosition
          (parseLexeme (string "if")) >> return (If startPosition)

parseThen :: CalcLangLexer Token
parseThen = do
            startPosition <- getPosition
            (parseLexeme (string "then")) >> return (Then startPosition)

parseElse :: CalcLangLexer Token
parseElse = do
            startPosition <- getPosition
            (parseLexeme (string "else")) >> return (Else startPosition)

parseFunc :: CalcLangLexer Token
parseFunc = do
            startPosition <- getPosition
            (parseLexeme (string "func")) >> return (Func startPosition)

parseLet :: CalcLangLexer Token
parseLet = do
           startPosition <- getPosition
           (parseLexeme (string "let")) >> return (Let startPosition)

parseDol :: CalcLangLexer Token
parseDol = do
           startPosition <- getPosition
           c <- (char '$')
           d <- many1 digit
           p <- (char '.')
           d1 <- digit
           d2 <- parseLexeme digit
           return (Dol ((c : d) ++ [p, d1, d2]) startPosition)

parsePerc :: CalcLangLexer Token
parsePerc = do
            startPosition <- getPosition
            p <- (char '%')
            d <- many1 digit
            p <- (char '.')
            delse <- parseLexeme (many1 digit)
            return (Perc ((p : d) ++ [p] ++ delse) startPosition)
            
            

parseToken :: CalcLangLexer Token
parseToken = try parseDol <|> try parsePerc <|> try parsePeriod <|> try parseElse <|> try parseThen <|> try parseIf <|> try parseGtOrEq <|> try parseLtOrEq <|> try parseGT <|> try parseLT <|> try parsePow <|> try parseEq <|> try parseNot <|> try parseDiv <|> try parseTimes <|> try parseMinus <|> try parsePlus <|> try parseLBrack <|> try parseRBrack <|> try parseComma <|> try parseLPar <|> try parseRPar <|> try parseFunc <|> try parseLet <|> try parseNum <|> try parseBool <|> try parseIdent

parseTokens :: CalcLangLexer [Token]
parseTokens = spaces *> many parseToken

--The Lexer is completed as shown above it is a Parser that parses the program into a flat list of tokens. The rule order is important here because an Ident can also be Then or an if or a true. We need to check the most specific Parser first then go toward the least specific

--Next we need to design the Parser...
type CalcLangParser a = ParsecT String () IO a

data AstNode = EqualOperation Pos AstNode AstNode
             | LessThenOrEqualsOperation Pos AstNode AstNode
             | GreaterThenOrEqualsOperation Pos AstNode AstNode
             | LessThenOperation Pos AstNode AstNode
             | GreaterThenOperation Pos AstNode AstNode
             | AdditionOperation Pos AstNode AstNode
             | SubtractionOperation Pos AstNode AstNode
             | MultiplicationOperation Pos AstNode AstNode
             | DotProductOperation Pos AstNode AstNode
             | DivisionOperation Pos AstNode AstNode
             | PowerOperation Pos AstNode AstNode
             | IntNumberAst Pos String
             | RealNumberAst Pos String
             | BooleanAst Pos String
             | SetAst Pos [AstNode]
             | TupleAst Pos [AstNode]
             | IdentAst Pos Char
             | DollarAst Pos String
             | PercentAst Pos String
             | FunctionCall Pos Char [AstNode]
             | NegateOperation Pos AstNode
             | NotOperation Pos AstNode
             | FunctionDef Pos Char [AstNode] AstNode
             | Assign Pos Char AstNode
             | IfExpr Pos AstNode AstNode AstNode
             deriving (Eq, Show)

parseBoolean :: CalcLangParser AstNode
parseBoolean = do
               start <- getPosition
               b <- parseBool
               case b of
                 (TF x _) -> return (BooleanAst start x)


parseSet :: CalcLangParser AstNode
parseSet = do
           start <- getPosition
           parseLBrack
           x <- parseExpressionList
           parseRBrack
           return (SetAst start x)

parseTuple :: CalcLangParser AstNode
parseTuple = do
             start <- getPosition
             parseLPar
             x <- parseExpressionList
             parseRPar
             return (TupleAst start x)

parseIfExpr :: CalcLangParser AstNode
parseIfExpr = do
              start <- getPosition
              parseIf
              cond <- parseExpression
              parseThen
              ifTrue <- parseExpression
              parseElse
              ifFalse <- parseExpression
              return (IfExpr start cond ifTrue ifFalse)

parseDollarAst :: CalcLangParser AstNode
parseDollarAst = do
                 start <- getPosition
                 x <- parseDol
                 case x of
                   Dol a p -> return (DollarAst start a)

parsePercentAst :: CalcLangParser AstNode
parsePercentAst = do
                  start <- getPosition
                  x <- parsePerc
                  case x of
                    Perc a p -> return (DollarAst start a)


parseIntNumber :: CalcLangParser AstNode
parseIntNumber = do
                 startPosition <- getPosition
                 x <- parseIntNum
                 case x of
                   (IntNum s p) -> return (IntNumberAst p s)

parseRealNumber :: CalcLangParser AstNode
parseRealNumber = do
                  startPosition <- getPosition
                  x <- parseRealNum
                  case x of
                    (RealNum s p) -> return (RealNumberAst startPosition s)

parseNumber :: CalcLangParser AstNode
parseNumber = try parseRealNumber <|> try parseIntNumber
              

parseIdentifier :: CalcLangParser AstNode
parseIdentifier = do
                  startPosition <- getPosition
                  x <- parseIdent
                  case x of
                    Ident y _ -> return (IdentAst startPosition y)

parseFunctionCall :: CalcLangParser AstNode
parseFunctionCall = do
                    start <- getPosition
                    name <- parseIdentifier
                    parseLPar
                    l <- parseExpressionList
                    parseRPar
                    case name of
                          IdentAst _ n -> return (FunctionCall start n l)

parsePrimaryExpression :: CalcLangParser AstNode
parsePrimaryExpression = try parseDollarAst <|> try parsePercentAst <|> try parseNumber <|> try parseTuple <|> try parseSet <|> try parseBoolean <|> try parseIfExpr <|> try parseFunctionCall <|> try parseIdentifier

parseUnaryOperation :: CalcLangParser AstNode
parseUnaryOperation = try parseNotOperation <|> try parseNegationOperation <|> parsePrimaryExpression


parseNegationOperation :: CalcLangParser AstNode
parseNegationOperation = do
                         start <- getPosition
                         parseMinus
                         exp <- parseUnaryOperation
                         return (NegateOperation start exp)
                         

parseNotOperation :: CalcLangParser AstNode
parseNotOperation = do
                    start <- getPosition
                    parseNot
                    exp <- parseUnaryOperation
                    return (NotOperation start exp)

parsePowerOp :: CalcLangParser (AstNode -> AstNode -> AstNode)
parsePowerOp = do
               start <- getPosition
               parsePow >> return (PowerOperation start)

parsePowerOperation :: CalcLangParser AstNode
parsePowerOperation = chainr1 parseUnaryOperation parsePowerOp

parseDivOp :: CalcLangParser (AstNode -> AstNode -> AstNode)
parseDivOp = do
             start <- getPosition
             parseDiv >> return (DivisionOperation start)
                    
parseMultOp :: CalcLangParser (AstNode -> AstNode -> AstNode)
parseMultOp = do
              start <- getPosition
              parseTimes >> return (MultiplicationOperation start)

parseDotOp :: CalcLangParser (AstNode -> AstNode -> AstNode)
parseDotOp = do
             start <- getPosition
             parsePeriod >> return (DotProductOperation start)

parseMultDivOp :: CalcLangParser AstNode
parseMultDivOp = chainl1 parsePowerOperation (try parseMultOp <|> try parseDivOp <|> try parseDotOp)

parseAddOp :: CalcLangParser (AstNode -> AstNode -> AstNode)
parseAddOp = do
             start <- getPosition
             parsePlus >> return (AdditionOperation start)

parseSubOp :: CalcLangParser (AstNode -> AstNode -> AstNode)
parseSubOp = do
             start <- getPosition
             parseMinus >> return (SubtractionOperation start)

parseAddSubOp :: CalcLangParser AstNode
parseAddSubOp = chainl1 parseMultDivOp (parseAddOp <|> parseSubOp)

parseExpression :: CalcLangParser AstNode
parseExpression = parseBinaryOperation

parseLogicalOperation :: CalcLangParser AstNode
parseLogicalOperation = try parseEqualsOperation <|> try parseLessThenOrEqualsOperation <|> try parseLessThenOperation <|> try parseGreaterThenOperation <|> try parseGreaterThenOrEqualsOperation  

parseEqualsOperation :: CalcLangParser AstNode
parseEqualsOperation = do
                       start <- getPosition
                       x <- parseAddSubOp
                       parseEq
                       y <- parseAddSubOp
                       return (EqualOperation start x y)

parseLessThenOrEqualsOperation :: CalcLangParser AstNode
parseLessThenOrEqualsOperation = do
                                 start <- getPosition
                                 x <- parseAddSubOp
                                 parseLtOrEq
                                 y <- parseAddSubOp
                                 return (LessThenOrEqualsOperation start x y)

parseLessThenOperation :: CalcLangParser AstNode
parseLessThenOperation = do
                         start <- getPosition
                         x <- parseAddSubOp
                         parseLT
                         y <- parseAddSubOp
                         return (LessThenOperation start x y)

parseGreaterThenOrEqualsOperation :: CalcLangParser AstNode
parseGreaterThenOrEqualsOperation = do
                                    start <- getPosition
                                    x <- parseAddSubOp
                                    parseGtOrEq
                                    y <- parseAddSubOp
                                    return (GreaterThenOrEqualsOperation start x y)

parseGreaterThenOperation :: CalcLangParser AstNode
parseGreaterThenOperation = do
                            start <- getPosition
                            x <- parseAddSubOp
                            parseGT
                            y <- parseAddSubOp
                            return (GreaterThenOperation start x y)


                        

parseBinaryOperation :: CalcLangParser AstNode
parseBinaryOperation = try parseLogicalOperation <|> try parseAddSubOp

parseExpressionList :: CalcLangParser [AstNode]
parseExpressionList = do
                      x <- (sepBy parseExpression parseComma)
                      return (reverse x)


parseParamaters :: CalcLangParser [AstNode]
parseParamaters = do
                  x <- (sepBy parseIdentifier parseComma)
                  return (reverse x)

parseFunctionDefinition :: CalcLangParser AstNode
parseFunctionDefinition = do
                          pos <- getPosition
                          parseFunc
                          x <- parseIdentifier
                          parseLPar
                          y <- parseParamaters
                          parseRPar
                          parseEq
                          z <- parseExpression
                          case x of
                            IdentAst _ s -> return (FunctionDef pos s y z)

parseMacroAssignment :: CalcLangParser AstNode
parseMacroAssignment = do
                       start <- getPosition
                       parseLet
                       x <- parseIdentifier
                       parseEq
                       e <- parseExpression
                       case x of
                         IdentAst _ s -> return (Assign start s e)
                            

parseAstNode :: CalcLangParser AstNode
parseAstNode = spaces *> (try parseFunctionDefinition <|> try parseMacroAssignment <|> try parseExpression)

--Now the Parser is done and we need to costruct the interpreter we will define a few tools like a symboltable and values. This language will contain lazy evaluation just like haskell. Meaning the VariableTable and the FunctionTable will store Expressions that are computed when needed.

data CalcLangValue = BoolVal Bool
                   | IntVal Int
                   | RealVal Double
                   | VoidVal VariableTable FunctionTable
                   | TupleVal [CalcLangValue]
                   | SetVal [CalcLangValue]
                   | DollarVal Double
                   | PercentVal Double
                   | ErrorVal [String]
                   deriving (Show, Eq)

data STable a b = SymbolTable [(a, b)] deriving (Show, Eq)
type VariableTable = STable Char AstNode
type FunctionTable = STable Char ([AstNode], AstNode)

addEntry :: STable a b -> (a, b) -> STable a b
addEntry table entry = case table of
                         SymbolTable x -> SymbolTable (entry : x)

removeEntry :: (Eq a, Show a, Show b) => STable a b -> a -> STable a b
removeEntry table key = case table of
                          SymbolTable [] -> SymbolTable []
                          SymbolTable list -> SymbolTable (removeKey list key)

removeKey :: (Eq key) => [(key, a)] -> key -> [(key, a)]
removeKey list key = case list of
                       [] -> []
                       ((itemKey, _) : rest) -> case itemKey == key of
                                                  True -> rest
                                                  False -> removeKey rest key
                             
getEntry :: (Eq a) => STable a b -> a -> Maybe b
getEntry table key = case table of
                       SymbolTable [] -> Nothing
                       SymbolTable list -> getKey list key

getKey :: (Eq key) => [(key,a)] -> key -> Maybe a
getKey list key = case list of
                    [] -> Nothing
                    ((elemKey, elem) : rest) -> case elemKey == key of
                                                  True -> Just elem
                                                  False -> (getKey rest key)
                        
                           
                           
toErrorLog :: [String] -> String
toErrorLog errors = case errors of
                      [] -> ""
                      (current:[]) -> current ++ "\n"
                      (current:rest) -> (toErrorLog rest) ++ current ++ "\n"                           

toStr :: [CalcLangValue] -> String
toStr list = case list of
               [] -> ""
               (val:[]) -> toString val
               (val:rest) -> (toStr rest) ++ ", " ++ (toString val)

toString :: CalcLangValue -> String
toString val = case val of
                 IntVal val -> show val
                 RealVal val -> show val
                 TupleVal val -> "(" ++ (toStr val) ++ ")"
                 SetVal val -> "{" ++ (toStr val) ++ "}"
                 DollarVal val -> "$" ++ (showFFloat (Just 2) val "")
                 PercentVal val -> (showFFloat (Just 2) (val*100.0) "") ++ "%"
                 BoolVal val -> if val then "TRUE" else "FALSE"
                 ErrorVal val -> "<<<~~~ERROR~~~>>>\n\n" ++ (toErrorLog val)
                 otherwise -> ""

generateParam :: AstNode -> AstNode -> (Char, AstNode)
generateParam paramLexeme toExpr = case paramLexeme of
                                     IdentAst _ x -> (x, toExpr)

interpret :: AstNode -> VariableTable -> FunctionTable -> CalcLangValue
interpret node vT fT = case node of
                          EqualOperation _ x y -> equalVals (interpret x vT fT) (interpret y vT fT)
                          LessThenOrEqualsOperation _ x y -> lessOrEqualVals (interpret x vT fT) (interpret y vT fT)
                          GreaterThenOrEqualsOperation _ x y -> greaterOrEqualVals (interpret x vT fT) (interpret y vT fT)
                          LessThenOperation _ x y -> lessThanVals (interpret x vT fT) (interpret y vT fT)
                          GreaterThenOperation _ x y -> greaterThanVals (interpret x vT fT) (interpret y vT fT)
                          AdditionOperation _ x y -> addVals (interpret x vT fT) (interpret y vT fT)
                          SubtractionOperation _ x y -> subtractVals (interpret x vT fT) (interpret y vT fT)
                          MultiplicationOperation _ x y -> multVals (interpret x vT fT) (interpret y vT fT)
                          DivisionOperation _ x y -> divVals (interpret x vT fT) (interpret y vT fT)
                          DotProductOperation _ x y -> dotProductVals (interpret x vT fT) (interpret y vT fT)
                          PowerOperation _ x y -> powVals (interpret x vT fT) (interpret y vT fT)
                          DollarAst _ x -> DollarVal (read x :: Double)
                          PercentAst _ x -> PercentVal (read x :: Double)
                          IntNumberAst _ x -> IntVal (read x :: Int) 
                          RealNumberAst _ x -> RealVal (read x :: Double)
                          BooleanAst _ x -> BoolVal (if x == "TRUE" then True else False)
                          SetAst _ x -> SetVal (map (\s -> interpret s vT fT) x)
                          TupleAst _ x -> TupleVal (map (\s -> interpret s vT fT) x)
                          IdentAst _ x -> do
                                          let entry = (getEntry vT x)
                                          case entry of
                                            Just y -> (interpret y vT fT)
                                            Nothing -> ErrorVal [("Variable " ++ [x] ++ " not found")]
                          FunctionCall _ x y -> do
                                                let entry = (getEntry fT x)
                                                case entry of
                                                    Just (params, retExpr) -> do
                                                                              let zippedData = (zipWith generateParam params y)
                                                                              let vTable = (foldl (\table tuple -> addEntry table tuple) vT zippedData)
                                                                              let retVal = (interpret retExpr vTable fT)
                                                                              (retVal)
                                                    Nothing -> ErrorVal ["Function " ++ [x] ++ " not found"]
                          NegateOperation _ x -> negVal (interpret x vT fT)
                          NotOperation _ x -> notVal (interpret x vT fT)
                          FunctionDef _ s l e -> VoidVal vT (addEntry fT (s, (l, e)))
                          Assign _ s e -> VoidVal (addEntry vT (s,e)) fT
                          IfExpr _ cond ifTrue ifFalse -> if (asBool (interpret cond vT fT)) then interpret ifTrue vT fT else interpret ifFalse vT fT

asBool :: CalcLangValue -> Bool
asBool val = case val of
               BoolVal val -> val
               IntVal val -> val /= 0
               RealVal val -> val /= 0
               PercentVal val -> val /= 0

asReal :: CalcLangValue -> Double
asReal val = case val of
               IntVal val -> (fromIntegral val :: Double)
               DollarVal val -> val
               RealVal val -> val
               PercentVal val -> val
               BoolVal val -> if val then 1.0 else 0.0
               _ -> -1.0

powVals :: CalcLangValue -> CalcLangValue -> CalcLangValue
powVals v1 v2 = case (v1,v2) of
                 (ErrorVal v1, ErrorVal v2) -> ErrorVal (v1 ++ v2)
                 (ErrorVal v1, _) -> ErrorVal v1
                 (_, ErrorVal v2) -> ErrorVal v2
                 (TupleVal v1, _) -> TupleVal (map (\x -> (powVals x v2)) v1)
                 (SetVal v1, _) -> SetVal (map (\x -> (powVals x v2)) v1)
                 (IntVal v1, IntVal v2) -> IntVal (v1^v2)
                 (IntVal v1, BoolVal v2) -> IntVal (v1^(if v2 then 1 else 0))
                 (IntVal v1, RealVal v2) -> RealVal ((fromIntegral v1 :: Double)**v2)
                 (RealVal v1, IntVal v2) -> RealVal (v1**(fromIntegral v2 :: Double))
                 (RealVal v1, BoolVal v2) -> RealVal (v1**(if v2 then 1.0 else 0.0))
                 (RealVal v1, RealVal v2) -> RealVal (v1**v2)
                 (RealVal v1, PercentVal v2) -> RealVal (v1**v2)
                 (BoolVal v1, IntVal v2) -> IntVal ((if v1 then 1 else 0)^v2)
                 (BoolVal v1, BoolVal v2) -> BoolVal (((if v1 then 1 else 0)^(if v2 then 1 else 0) /= 0))
                 (BoolVal v1, RealVal v2) -> RealVal ((if v1 then 1.0 else 0.0)**v2)
                 (PercentVal v1, RealVal v2) -> PercentVal (v1**v2)
                 (PercentVal v1, IntVal v2) -> PercentVal (v1**(fromIntegral v2 :: Double))
                 (x,y) -> ErrorVal [("Unable to multiply " ++ show x ++ " by " ++ show y)]

multVals :: CalcLangValue -> CalcLangValue -> CalcLangValue
multVals v1 v2 = case (v1,v2) of
                 (ErrorVal v1, ErrorVal v2) -> ErrorVal (v1 ++ v2)
                 (ErrorVal v1, _) -> ErrorVal v1
                 (_, ErrorVal v2) -> ErrorVal v2
                 (TupleVal v1, SetVal v2) -> TupleVal (map (\(x,y) -> multVals x y) (zip v1 v2))
                 (TupleVal v1, TupleVal v2) -> TupleVal (map (\(x,y) -> multVals x y) (zip v1 v2))
                 (SetVal v1, TupleVal v2) -> SetVal (map (\(x,y) -> multVals x y) (zip v1 v2))
                 (SetVal v1, SetVal v2) -> SetVal (map (\(x,y) -> multVals x y) (zip v1 v2))
                 (_, TupleVal v2) -> TupleVal (map (\x -> (multVals v1 x)) v2)
                 (_, SetVal v2) -> SetVal (map (\x -> (multVals v1 x)) v2)
                 (TupleVal v1, _) -> TupleVal (map (\x -> (multVals x v2)) v1)
                 (SetVal v1, _) -> SetVal (map (\x -> (multVals x v2)) v1)
                 (IntVal v1, IntVal v2) -> IntVal (v1 * v2)
                 (IntVal v1, BoolVal v2) -> IntVal (v1 * (if v2 then 1 else 0))
                 (IntVal v1, RealVal v2) -> RealVal ((fromIntegral v1 :: Double) * v2)
                 (IntVal v1, PercentVal v2) -> RealVal ((fromIntegral v1 :: Double) * v2)
                 (IntVal v1, DollarVal v2) -> DollarVal ((fromIntegral v1 :: Double) * v2)
                 (RealVal v1, IntVal v2) -> RealVal (v1 * (fromIntegral v2 :: Double))
                 (RealVal v1, BoolVal v2) -> RealVal (v1 * (if v2 then 1.0 else 0.0))
                 (RealVal v1, RealVal v2) -> RealVal (v1 * v2)
                 (RealVal v1, PercentVal v2) -> RealVal (v1 * v2)
                 (RealVal v1, DollarVal v2) -> DollarVal (v1 * v2)
                 (BoolVal v1, IntVal v2) -> IntVal ((if v1 then 1 else 0) * v2)
                 (BoolVal v1, BoolVal v2) -> BoolVal (((if v1 then 1 else 0)*(if v2 then 1 else 0)) /= 0)
                 (BoolVal v1, RealVal v2) -> RealVal ((if v1 then 1.0 else 0.0) * v2)
                 (BoolVal v1, PercentVal v2) -> RealVal ((if v1 then 1.0 else 0.0) * v2)
                 (BoolVal v1, DollarVal v2) -> DollarVal ((if v1 then 1.0 else 0.0) * v2)
                 (DollarVal v1, PercentVal v2) -> DollarVal (v1 * v2)
                 (DollarVal v1, IntVal v2) -> DollarVal (v1 * (fromIntegral v2 :: Double))
                 (DollarVal v1, RealVal v2) -> DollarVal (v1 * v2)
                 (DollarVal v1, BoolVal v2) -> DollarVal (v1 * (if v2 then 1.0 else 0.0))
                 (PercentVal v1, PercentVal v2) -> PercentVal (v1*v2)
                 (PercentVal v1, RealVal v2) -> PercentVal (v1*v2)
                 (PercentVal v1, IntVal v2) -> PercentVal (v1 * (fromIntegral v2 :: Double))
                 (PercentVal v1, BoolVal v2) -> PercentVal (v1 * (if v2 then 1.0 else 0.0))
                 (x,y) -> ErrorVal [("Unable to multiply " ++ show x ++ " by " ++ show y)]


divVals :: CalcLangValue -> CalcLangValue -> CalcLangValue
divVals v1 v2 = case (v1,v2) of
                 (ErrorVal v1, ErrorVal v2) -> ErrorVal (v1 ++ v2)
                 (ErrorVal v1, _) -> ErrorVal v1
                 (_, ErrorVal v2) -> ErrorVal v2
                 (TupleVal v1, SetVal v2) -> TupleVal (map (\(x,y) -> divVals x y) (zip v1 v2))
                 (TupleVal v1, TupleVal v2) -> TupleVal (map (\(x,y) -> divVals x y) (zip v1 v2))
                 (SetVal v1, TupleVal v2) -> SetVal (map (\(x,y) -> divVals x y) (zip v1 v2))
                 (SetVal v1, SetVal v2) -> SetVal (map (\(x,y) -> divVals x y) (zip v1 v2))
                 (_, TupleVal v2) -> TupleVal (map (\x -> (divVals v1 x)) v2)
                 (_, SetVal v2) -> SetVal (map (\x -> (divVals v1 x)) v2)
                 (TupleVal v1, _) -> TupleVal (map (\x -> (divVals x v2)) v1)
                 (SetVal v1, _) -> SetVal (map (\x -> (divVals x v2)) v1)
                 (IntVal v1, IntVal v2) -> RealVal ((fromIntegral v1 :: Double) / (fromIntegral v2 :: Double))
                 (IntVal v1, BoolVal v2) -> RealVal ((fromIntegral v1 :: Double) / (if v2 then 1.0 else 0.0))
                 (IntVal v1, RealVal v2) -> RealVal ((fromIntegral v1 :: Double) / v2)
                 (IntVal v1, PercentVal v2) -> RealVal ((fromIntegral v1 :: Double) / v2)
                 (RealVal v1, IntVal v2) -> RealVal (v1 / (fromIntegral v2 :: Double))
                 (RealVal v1, BoolVal v2) -> RealVal (v1 / (if v2 then 1.0 else 0.0))
                 (RealVal v1, RealVal v2) -> RealVal (v1 / v2)
                 (RealVal v1, PercentVal v2) -> RealVal (v1 / v2)
                 (BoolVal v1, IntVal v2) -> RealVal ((if v1 then 1.0 else 0.0)/(fromIntegral v2 :: Double))
                 (BoolVal v1, BoolVal v2) -> RealVal ((if v1 then 1 else 0)/(if v2 then 1 else 0))
                 (BoolVal v1, RealVal v2) -> RealVal ((if v1 then 1.0 else 0.0)/v2)
                 (BoolVal v1, PercentVal v2) -> RealVal ((if v1 then 1.0 else 0.0)/v2)
                 (DollarVal v1, DollarVal v2) -> RealVal (v1 / v2)
                 (DollarVal v1, PercentVal v2) -> DollarVal (v1 / v2)
                 (DollarVal v1, IntVal v2) -> DollarVal (v1 / (fromIntegral v2 :: Double))
                 (DollarVal v1, RealVal v2) -> DollarVal (v1 / v2)
                 (PercentVal v1, PercentVal v2) -> RealVal (v1 / v2)
                 (PercentVal v1, RealVal v2) -> PercentVal (v1 / v2)
                 (PercentVal v1, IntVal v2) -> PercentVal (v1 / (fromIntegral v2 :: Double))
                 (x,y) -> ErrorVal [("Unable to divide " ++ show x ++ " by " ++ show y)]

dotProductVals :: CalcLangValue -> CalcLangValue -> CalcLangValue
dotProductVals v1 v2 = case (v1,v2) of
                 (ErrorVal v1, ErrorVal v2) -> ErrorVal (v1 ++ v2)
                 (ErrorVal v1, _) -> ErrorVal v1
                 (_, ErrorVal v2) -> ErrorVal v2
                 (TupleVal v1, SetVal v2) -> (foldl (\x y -> addVals x y) (IntVal 0) (map (\(x,y) -> multVals x y) (zip v1 v2))) 
                 (TupleVal v1, TupleVal v2) -> (foldl (\x y -> addVals x y) (IntVal 0) (map (\(x,y) -> multVals x y) (zip v1 v2))) 
                 (SetVal v1, TupleVal v2) -> (foldl (\x y -> addVals x y) (IntVal 0) (map (\(x,y) -> multVals x y) (zip v1 v2))) 
                 (SetVal v1, SetVal v2) -> (foldl (\x y -> addVals x y) (IntVal 0) (map (\(x,y) -> multVals x y) (zip v1 v2))) 
                 (x,y) -> ErrorVal [("Unable to perform dot product on  " ++ show x ++ " and " ++ show y)]

addVals :: CalcLangValue -> CalcLangValue -> CalcLangValue
addVals v1 v2 = case (v1,v2) of
                 (ErrorVal v1, ErrorVal v2) -> ErrorVal (v1 ++ v2)
                 (ErrorVal v1, _) -> ErrorVal v1
                 (_, ErrorVal v2) -> ErrorVal v2
                 (TupleVal v1, SetVal v2) -> TupleVal (map (\(x, y) -> addVals x y) (zip v1 v2))
                 (TupleVal v1, TupleVal v2) -> TupleVal (map (\(x, y) -> addVals x y) (zip v1 v2))
                 (SetVal v1, TupleVal v2) -> SetVal (map (\(x, y) -> addVals x y) (zip v1 v2))
                 (SetVal v1, SetVal v2) -> SetVal (map (\(x, y) -> addVals x y) (zip v1 v2))
                 (_, TupleVal v2) -> TupleVal (map (\x -> (addVals v1 x)) v2)
                 (_, SetVal v2) -> SetVal (map (\x -> (addVals v1 x)) v2)
                 (TupleVal v1, _) -> TupleVal (map (\x -> (addVals x v2)) v1)
                 (SetVal v1, _) -> SetVal (map (\x -> (addVals x v2)) v1)
                 (IntVal v1, IntVal v2) -> IntVal (v1 + v2)
                 (IntVal v1, BoolVal v2) -> IntVal (v1 + (if v2 then 1 else 0))
                 (IntVal v1, RealVal v2) -> RealVal ((fromIntegral v1 :: Double) + v2)
                 (RealVal v1, IntVal v2) -> RealVal (v1 + (fromIntegral v2 :: Double))
                 (RealVal v1, BoolVal v2) -> RealVal (v1 + (if v2 then 1.0 else 0.0))
                 (RealVal v1, RealVal v2) -> RealVal (v1 + v2)
                 (BoolVal v1, IntVal v2) -> IntVal ((if v1 then 1 else 0)+v2)
                 (BoolVal v1, BoolVal v2) -> IntVal ((if v1 then 1 else 0)+(if v2 then 1 else 0))
                 (BoolVal v1, RealVal v2) -> RealVal ((if v1 then 1.0 else 0.0) + v2)
                 (DollarVal v1, DollarVal v2) -> DollarVal(v1+v2)
                 (PercentVal v1, PercentVal v2) -> PercentVal(v1+v2)
                 (x,y) -> ErrorVal [("Unable to add " ++ show x ++ " and " ++ show y)]

subtractVals :: CalcLangValue -> CalcLangValue -> CalcLangValue
subtractVals v1 v2 = addVals v1 (negVal v2)

negVal :: CalcLangValue -> CalcLangValue
negVal v1 = case v1 of
                 ErrorVal v1 -> ErrorVal v1
                 TupleVal v1 -> TupleVal (map (\x -> negVal x) v1)
                 SetVal v1 -> SetVal (map (\x -> negVal x) v1)
                 IntVal v1 -> IntVal (-v1)
                 RealVal v1 -> RealVal (-v1)
                 BoolVal v1 -> IntVal (-(if v1 then 1 else 0))
                 DollarVal v1 -> DollarVal (-v1)
                 PercentVal v1 -> PercentVal (-v1)
                 x -> ErrorVal [("Unable to negate " ++ show x)]

notVal :: CalcLangValue -> CalcLangValue
notVal v1 = case v1 of
                 ErrorVal v1 -> ErrorVal v1
                 TupleVal v1 -> TupleVal (map (\x -> notVal x) v1)
                 SetVal v1 -> SetVal (map (\x -> notVal x) v1)
                 IntVal v1 -> BoolVal (v1 /= 0)
                 RealVal v1 -> BoolVal (v1 /= 0.0)
                 BoolVal v1 -> BoolVal (not v1)
                 x -> ErrorVal [("Unable to perform logical not on " ++ show x)]

andVals :: CalcLangValue -> CalcLangValue -> CalcLangValue
andVals v1 v2 = case (v1, v2) of
              (ErrorVal v1, ErrorVal v2) -> ErrorVal (v1 ++ v2)
              (ErrorVal v1, _) -> ErrorVal v1
              (_, ErrorVal v2) -> ErrorVal v2
              (_, TupleVal v2) -> ErrorVal [("Error: Tuple value found in boolean expression")]
              (_, SetVal v2) -> ErrorVal [("Error: Set value found in boolean expression")]
              (TupleVal v1, _) -> ErrorVal [("Error: Tuple value found in boolean expression")]
              (SetVal v1, _) -> ErrorVal [("Error: Set value found in boolean expression")]
              (DollarVal v1, _) -> ErrorVal [("Error: Dollar value found in boolean expression")]
              (_,DollarVal v2) -> ErrorVal [("Error: Dollar value found in boolean expression")]
              (PercentVal v1, _) -> ErrorVal [("Error: Dollar value found in boolean expression")]
              (_,PercentVal v2) -> ErrorVal [("Error: Dollar value found in boolean expression")]
              (v1,v2) -> BoolVal((asBool v1) && (asBool v2))


equalVals :: CalcLangValue -> CalcLangValue -> CalcLangValue
equalVals v1 v2 = case (v1,v2) of
                 (ErrorVal v1, ErrorVal v2) -> ErrorVal (v1 ++ v2)
                 (ErrorVal v1, _) -> ErrorVal v1
                 (_, ErrorVal v2) -> ErrorVal v2
                 (TupleVal v1, SetVal v2) -> foldl (\x y -> andVals x y) (BoolVal True) (map (\(x,y) -> equalVals x y) (zip v1 v2))
                 (TupleVal v1, TupleVal v2) -> foldl (\x y -> andVals x y) (BoolVal True) (map (\(x,y) -> equalVals x y) (zip v1 v2))
                 (SetVal v1, TupleVal v2) -> foldl (\x y -> andVals x y) (BoolVal True) (map (\(x,y) -> equalVals x y) (zip v1 v2))
                 (SetVal v1, SetVal v2) -> foldl (\x y -> andVals x y) (BoolVal True) (map (\(x,y) -> equalVals x y) (zip v1 v2))
                 (IntVal v1, IntVal v2) -> BoolVal (v1 == v2)
                 (IntVal v1, BoolVal v2) -> BoolVal (v1 == (if v2 then 1 else 0))
                 (IntVal v1, RealVal v2) -> BoolVal ((fromIntegral v1 :: Double) == v2)
                 (RealVal v1, IntVal v2) -> BoolVal (v1 == (fromIntegral v2 :: Double))
                 (RealVal v1, BoolVal v2) -> BoolVal (v1 == if v2 then 1.0 else 0.0)
                 (RealVal v1, RealVal v2) -> BoolVal (v1 == v2)
                 (BoolVal v1, IntVal v2) -> BoolVal ((if v1 then 1 else 0) == v2)
                 (BoolVal v1, BoolVal v2) -> BoolVal (v1 == v2)
                 (BoolVal v1, RealVal v2) -> BoolVal ((if v1 then 1.0 else 2.0) == v2)
                 (DollarVal v1, DollarVal v2) -> BoolVal(v1 == v2)
                 (PercentVal v1, PercentVal v2) -> BoolVal(v1 == v2)
                 (x,y) -> ErrorVal [("Unable to check for equality on types " ++ show x ++ " and " ++ show y)]

lessThanVals :: CalcLangValue -> CalcLangValue -> CalcLangValue
lessThanVals v1 v2 = case (v1,v2) of
                 (ErrorVal v1, ErrorVal v2) -> ErrorVal (v1 ++ v2)
                 (ErrorVal v1, _) -> ErrorVal v1
                 (_, ErrorVal v2) -> ErrorVal v2
                 (IntVal v1, IntVal v2) -> BoolVal (v1 < v2)
                 (IntVal v1, BoolVal v2) -> BoolVal (v1 < (if v2 then 1 else 0))
                 (IntVal v1, RealVal v2) -> BoolVal ((fromIntegral v1 :: Double) < v2)
                 (RealVal v1, IntVal v2) -> BoolVal (v1 < (fromIntegral v2 :: Double))
                 (RealVal v1, BoolVal v2) -> BoolVal (v1 < (if v2 then 1.0 else 0.0))
                 (RealVal v1, RealVal v2) -> BoolVal (v1 < v2)
                 (BoolVal v1, IntVal v2) -> BoolVal ((if v1 then 1 else 0) < v2)
                 (BoolVal v1, BoolVal v2) -> BoolVal ((if v1 then 1 else 0) < (if v2 then 1 else 0))
                 (BoolVal v1, RealVal v2) -> BoolVal ((if v1 then 1.0 else 0.0) < v2)
                 (DollarVal v1, DollarVal v2) -> BoolVal(v1<v2)
                 (PercentVal v1, PercentVal v2) -> BoolVal(v1<v2)
                 (x,y) -> ErrorVal [("Unable to check for equality on types " ++ show x ++ " and " ++ show y)]

greaterThanVals :: CalcLangValue -> CalcLangValue -> CalcLangValue
greaterThanVals v1 v2 = case (v1,v2) of
                   (ErrorVal v1, ErrorVal v2) -> ErrorVal (v1 ++ v2)
                   (ErrorVal v1, _) -> ErrorVal v1
                   (_, ErrorVal v2) -> ErrorVal v2
                   (IntVal v1, IntVal v2) -> BoolVal (v1 > v2)
                   (IntVal v1, BoolVal v2) -> BoolVal (v1 > (if v2 then 1 else 0))
                   (IntVal v1, RealVal v2) -> BoolVal ((fromIntegral v1 :: Double) > v2)
                   (RealVal v1, IntVal v2) -> BoolVal (v1 > (fromIntegral v2 :: Double))
                   (RealVal v1, BoolVal v2) -> BoolVal (v1 > (if v2 then 1.0 else 0.0))
                   (RealVal v1, RealVal v2) -> BoolVal (v1 > v2)
                   (BoolVal v1, IntVal v2) -> BoolVal ((if v1 then 1 else 0) > v2)
                   (BoolVal v1, BoolVal v2) -> BoolVal ((if v1 then 1 else 0) > (if v2 then 1 else 0))
                   (BoolVal v1, RealVal v2) -> BoolVal ((if v1 then 1.0 else 0.0) > v2)
                   (DollarVal v1, DollarVal v2) -> BoolVal(v1 > v2)
                   (PercentVal v1, PercentVal v2) -> BoolVal(v1 > v2)
                   (x,y) -> ErrorVal [("Unable to check for equality on types " ++ show x ++ " and " ++ show y)]

lessOrEqualVals :: CalcLangValue -> CalcLangValue -> CalcLangValue
lessOrEqualVals v1 v2 = notVal (greaterThanVals v1 v2)

greaterOrEqualVals :: CalcLangValue -> CalcLangValue -> CalcLangValue
greaterOrEqualVals v1 v2 = notVal (lessThanVals v1 v2)

runCommandLine :: VariableTable -> FunctionTable -> IO ()
runCommandLine vT fT = do
                       putStr ">>CalcLang>> "
                       hFlush stdout
                       input <- getLine
                       parseResult <- (runParserT parseAstNode () "" input)
                       case parseResult of
                         Left err -> print err
                         Right t -> do
                                    let interpreterResult = (interpret t vT fT)
                                    case interpreterResult of
                                      VoidVal vT fT -> runCommandLine vT fT
                                      ErrorVal x -> putStrLn (toErrorLog x)
                                      n -> putStrLn (toString n)
                                      


main :: IO ()
main = runCommandLine (SymbolTable []) (SymbolTable [])

